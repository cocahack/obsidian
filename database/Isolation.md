# Isolation (Transaction)

[[Transaction]] 의 4 가지 특성 중 하나인 Isolation에 대한 문서.

## 개념

보통 여러 클라이언트가 데이터베이스에 접근한다. 클라이언트들이 데이터베이스의 서로 다른 부분을 읽고 쓴다면 전혀 문제가 없겠지만, 일정 부분을 동시에 접근하면 동시성 문제에 직면하게 된다. 이를 해소하기 위해 isolation이 필요하다. 

Isolation은 여러 트랜잭션이 동시에 실행되지만 각각의 트랜잭션은 각자 혼자 데이터베이스를 쓰는 것처럼 보이게 해주는 속성이다.


### 격리 수준

앞서 개념에서 언급한 것처럼, 다른 트랜잭션의 동작과 완벽하게 격리하는 방법은 트랜잭션을 순차적으로 실행하는 것이다. 그러나 이 방법은 현실적이지 않다. 실시간성이 중요한 웹 서비스에서 다른 트랜잭션이 처리되기까지 기다리는 것은 말이 안된다. 이 때문에 격리 수준을 완화해 성능을 확보하는 trade-off를 대부분의 애플리케이션에서 적용하고 있다.

격리 수준에는 크게 네 가지가 있다.

- SERIALIZABLE
- REPEATABLE READ
- READ COMMITTED
- READ UNCOMMITTED

위에서 아래로 내려갈수록 완화된 격리 수준이며, 완화되었기 때문에 이상 현상(Abnomarly)이 발생할 수 있다.

#### READ COMMITTED

가장 기본적인 격리 수준은 READ COMMITTED이다. 그 아래의 READ UNCOMMITTED는 사실상 격리가 되지 않는다고 볼 수 있다.

이 수준에서는 두 가지의 이상 현상을 막아준다.

- 트랜잭션은 쿼리 조회 시 항상 커밋된 데이터만 보게 된다. (**Dirty read** 방지)
- 트랜잭션은 데이터를 쓸 때 커밋된 데이터만 덮어쓰게 된다. (**Dirty write** 방지)

> [!INFO]
> Dirty read가 발생하면 다른 트랜잭션이 변경했지만 아직 커밋되지 않은 내용을 보게 된다.
>  만약 다른 트랜잭션이 변경한 내용이 롤백되어 적용되지 않았지만, 롤백되기 전의 내용을 바탕으로 어떤 트랜잭션이 쓰기 작업을 했다면 예상치 못한 버그로 이어질 가능성이 있다. 
>  게다가 적용된 적이 없는 값을 기반으로 작업이 진행되었기 때문에 문제가 발생한 원인을 파악하기가 매우 어려울 것이다.

> [!INFO]
> READ COMMITTED에서는 한 트랜잭션이 변경한 커밋되지 않은 내용을 다른 트랜잭션이 덮어 쓰는 문제가 있을 수 있다. 이를 Dirty write라고 한다.
> 여러 객체를 동시에 갱신하는 dirty wrtie는 내용이 섞일 수 있다. 예를 들면 구매자는 A이지만 송장은 B에게 가는 상황이 발생할 수 있다.

##### 구현

READ COMMITTED를 구현하는 가장 흔한 방법은 레코드 수준의 락을 사용하는 것이다. 특정 객체를 변경하고 싶다면 우선 그 객체에 대한 락을 획득해야만 변경할 수 있도록 만드는 것이다.

그러나 이 방법은 실제로는 쓰이지 않는다. 읽기만 수행하는 트랜잭션은 오랫동안 실행되는 쓰기 트랜잭션이 완료될 때까지 기다려야 할 수 있기 때문이다.

락 대신 이전에 커밋된 값과 현재 쓰기 잠금을 가지고 있는 트랜잭션에서 쓴 값을 모두 기억하는 방법을 쓴다. 그렇게 하면 읽기만 수행하는 트랜잭션은 락을 획득할 필요 없이 이전에 커밋된 값을 바로 읽을 수 있다.

##### 한계점

이 수준에서 막을 수 없는 문제들이 존재한다.

1. 한 객체에 대한 race condition을 막을 수 없다.
2. 트랜잭션이 커밋되어 값이 변경되면 변경된 값을 한 번 읽었던 다른 트랜잭션은 만약 그 값을 다시 읽으면 변경된 값을 읽게 된다. (non-repeatable read 또는 read skew)

#### REPEATABLE READ

Non-repeatable read 가 발생하면 오랫동안 읽는 트랜잭션이나 분석용 쿼리에서 문제가 발생할 수 있다. 

- 특정 시점에 데이터를 백업하는데 백업 도중 커밋되어 새로운 내용이 적용되면 백업의 일부는 과거 데이터를, 일부는 과거 시점 이후의 데이터를 가지고 있게 될 수 있다.
- 데이터베이스에서 많은 부분을 스캔하는 분석용 쿼리에서 시점이 다른 내용을 보게될 수 있다.

REPEATABLE READ에서는 위와 같은 문제를 막을 수 있다.

##### 구현

REPEATABLE READ는 스냅샷 격리(Snapshot isolation)를 사용한다. 각 트랜잭션은 데이터베이스의 일관된 스냅샷을 읽게 된다. 다른 트랜잭션이 커밋되어 내용이 바뀌더라도 계속 특정 시점의 데이터를 읽을 수 있는 것이다.

> [!INFO]
> 스냅샷 격리 수준은 SQL 표준에 포함된 개념이 아니다. 때문에 오라클에서는 Serializable, Postgre 와 MySQL에서는 Repeatable read라고 부르는 등 서로 다른 이름을 사용한다.

스냅샷 격리는 [MVCC(Multi-version concurrency control)](MVCC.md)로 구현된다. READ COMMITTED에서 봤던 구현 방식에서 좀 더 일반화된 방식이라고 할 수 있다. 특정 시점의 객체 버전을 여러 개 가지고 있는 것이다.

##### 한계점

1. [갱신 손실(lost updates)](Lost%20Updates.md)를 방지할 수 없다.
2. [쓰기 스큐와 팬텀](Write%20skew.md)이 발생할 수 있다.

#### SERIALIZABLE

가장 강한 격리 수준으로, REPEATABLE READ에서 발생할 수 있는 쓰기 작업과 관련된 문제를 방지할 수 있다. 

여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 결과가 같도록 보장해준다.

Serializable 격리 수준을 제공하는 데이터베이스들은 세 가지 방법 중 하나를 사용한다.

1. 트랜잭션을 순차적으로 실행
2. 2-Phase Lock([[Lock(Database)]] 참조) 사용
3. 낙관적 동시성 제어(Optimistic Concurrency Control) 기법 사용 (예를 들면, Serializable Snapshot Isolation)


---
#db #transaction #MVCC

