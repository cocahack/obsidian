# Main concepts

## 이벤트

이벤트는 "어떤 것이 발생했다"는 사실을 기록한다. 카프카에서 레코드 또는 메시지라고도 불린다.

카프카에서 데이터를 읽고 쓸 때 이벤트의 형식을 갖게 된다. 개념적으로 이벤트는 키, 값, 타임스탬프, 그리고 메타데이터 헤더를 가진다.

## Producer & Consumer

프로듀서는 카프카로 이벤트를 쓰는(혹은 publish) 클라이언트 애플리케이션이다. 컨슈머는 이런 이벤트들을 구독하는 클라이언트 애플리케이션이다. 

카프카에서 프로듀서와 컨슈머는 완전히 분리되어 서로를 인지할 수 없으며, 이러한 설계는 카프카가 높은 확장성을 달성할 수 있다고 알려진 요소 중 하나이다. 예를 들면, 프로듀서는 컨슈머를 기다릴 필요가 없다. 카프카는 이벤트가 반드시 한 번만 처리되어야 한다는 등의 다양한 보장을 제공한다.

## 토픽



## 정의 및 특징

- 카프카에서는 토픽을 여러 개 생성할 수 있음
- DB 테이블 혹은 파일시스템의 디렉토리와 유사
- 프로듀서는 토픽에 데이터를 넣고, 컨슈머는 토픽에서 데이터를 빼냄
- 이름을 지정할 수 있어 명확한 이름을 사용하면 유지보수에 도움이 됨

## Details

### 파티션 1개

- 하나의 토픽은 여러 개의 파티션으로 구성될 수 있다.
- 파티션 번호는 0번부터 시작
- 데이터는 큐처럼 쌓임
- 컨슈머는 토픽에 쌓인 가장 오래된 데이터를 가져간다(FIFO)
- 컨슈머가 레코드를 가져가도 토픽의 데이터는 삭제되지 않고 파티션에 남아있다.
	- 새로운 컨슈머가 붙었을 때 이 남아있는 데이터를 가져가야 한다. 단, 조건이 있다.
		- 컨슈머 그룹이 다르고 `auto.offset.reset` 의 값이 `earliest` 여야 한다.
	- 이렇게 사용할 경우 동일 데이터를 두 번 이상 처리할 수 있다.

### 파티션 두 개 이상

- 키가 null 이고 기본 파티셔너를 사용
	- 라운드 로빈
- 키가 있고 기본 파티셔너를 사용
	- 키의 해시 값을 계산한 다음, 해시 값에 따라 특정 파티션에 할당
- 파티션은 확장만 되고 축소는 안된다.

### 레코드의 삭제

- 파티션의 레코드에는 최대 보존시간과 최대 보존 크기를 지정할 수 있다.
	- `log.retention.ms`
	- `log.retention.byte`
 

## References

- [카프카 공식 문서 - introduction](https://kafka.apache.org/documentation/#introduction)

---
#kafka